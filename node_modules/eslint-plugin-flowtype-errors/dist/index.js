'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _collect = require('./collect');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var runOnAllFiles = void 0;

function hasFlowPragma(source) {
  return source.getAllComments().some(function (comment) {
    return (/@flow/.test(comment.value)
    );
  });
}

function lookupFlowDir(context) {
  var root = process.cwd();
  var flowDirSetting = context.settings && context.settings['flowtype-errors'] && context.settings['flowtype-errors'].flowDir || '.';

  return _fs2.default.existsSync(_path2.default.join(root, flowDirSetting, '.flowconfig')) ? _path2.default.join(root, flowDirSetting) : root;
}

function stopOnExit(context) {
  return !!(context.settings && context.settings['flowtype-errors'] && context.settings['flowtype-errors'].stopOnExit);
}

exports.default = {
  rules: {
    'enforce-min-coverage': function enforceMinCoverage(context) {
      return {
        Program: function Program() {
          var source = context.getSourceCode();

          if (hasFlowPragma(source)) {
            var res = (0, _collect.coverage)(source.getText(), lookupFlowDir(context), stopOnExit(context), context.getFilename());

            if (res === true) {
              return;
            }

            var requiredCoverage = context.options[0];
            var coveredCount = res.coveredCount,
                uncoveredCount = res.uncoveredCount;

            /* eslint prefer-template: 0 */

            var percentage = Number(Math.round(coveredCount / (coveredCount + uncoveredCount) * 10000) + 'e-2');

            if (percentage < requiredCoverage) {
              context.report({
                loc: 1,
                message: 'Expected coverage to be at least ' + requiredCoverage + '%, but is: ' + percentage + '%'
              });
            }
          }
        }
      };
    },
    'show-errors': function showErrors(context) {
      return {
        Program: function Program() {
          var source = context.getSourceCode();
          var flowDir = lookupFlowDir(context);

          // Check to see if we should run on every file
          if (runOnAllFiles === undefined) {
            try {
              runOnAllFiles = _fs2.default.readFileSync(_path2.default.join(flowDir, '.flowconfig')).toString().includes('all=true');
            } catch (err) {
              runOnAllFiles = false;
            }
          }

          if (runOnAllFiles === false && !hasFlowPragma(source)) {
            return true;
          }

          var collected = (0, _collect.collect)(source.getText(), flowDir, stopOnExit(context), context.getFilename());

          if (collected === true) {
            return;
          }

          collected.forEach(function (_ref) {
            var loc = _ref.loc,
                message = _ref.message;

            context.report({
              loc: loc,
              message: message
            });
          });
        }
      };
    }
  }
};
module.exports = exports['default'];